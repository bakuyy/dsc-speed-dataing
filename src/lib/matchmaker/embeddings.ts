import "dotenv/config";
import OpenAI from "openai";
import dotenv from "dotenv";
import { getMCAnswer } from "./multipleChoiceMap.js";
import { supabase } from '../supabase.js';

dotenv.config();

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

interface Participant {
  // Primary key in form_responses
  id: string;
  // Basic info
  email: string;
  name: string;
  pronouns: string;
  program: string; // used for vector embedding
  year: string; // used for vector embedding
  social_media_links: string;
  // Open-ended responses
  // Career
  career: string; // used for vector embedding
  // Friendship
  friend_traits: string; // used for vector embedding
  self_desc: string; // used for vector embedding
  goal: string; // used for vector embedding
  // Interests
  fun: string; // used for vector embedding
  music: string; // used for vector embedding
  // Multiple choice: [a, b, c, d, e]
  class_seat: "a" | "b" | "c" | "d" | "e"; // used for vector embedding
  evil_hobby: "a" | "b" | "c" | "d" | "e"; // used for vector embedding
  most_likely_to: "a" | "b" | "c" | "d" | "e"; // used for vector embedding
  caught_watching: "a" | "b" | "c" | "d" | "e"; // used for vector embedding
  // Vector embedding for participant, generated by the OpenAI embeddings API.
  vector_embedding?: number[];
}

export async function updateFormResponsesTableWithVectorEmbeddings() {

  // fetch every row
  const { data: rows, error: fetchErr } = await supabase
    .from('form_responses')
    .select('*');
  if (fetchErr) throw fetchErr;
  if (!rows) return;

  for (const row of rows) { // for each row, build participant structure

    // Skip if vector_embedding already exists and is non-empty
    if (row.vector_embedding && row.vector_embedding.length > 0) {
      console.log(`Vector for ${row.id} already exists, skipping.`);
      continue;
    }

    const p: Participant = {
      ...row,
      class_seat: row.class_seat,
      evil_hobby: row.evil_hobby,
      most_likely_to: row.most_likely_to,
      caught_watching: row.caught_watching,
    };

    const textForEmbed = [ // concatenate everything for OpenAI embedding input
      p.program,
      p.year,
      p.career,
      p.friend_traits,
      p.self_desc,
      p.goal,
      p.fun,
      p.music,
      getMCAnswer('class_seat', p.class_seat), // turned MC answer [a, b, c, d, e] into its string response
      getMCAnswer('evil_hobby', p.evil_hobby),
      getMCAnswer('most_likely_to', p.most_likely_to),
      getMCAnswer('caught_watching', p.caught_watching),
    ].join(' â€¢ '); // separator for each field

    const embedRes = await openai.embeddings.create({ // create vector embedding
      model: 'text-embedding-3-small', // smaller embedding vectors to save Jacob's $4 money.
      input: textForEmbed,
    });
    const vector = embedRes.data[0].embedding;

    const { error: updErr } = await supabase
      .from('form_responses')
      .update({ vector_embedding: vector }) // insert into supabase the vector_embedding
      .eq('id', p.id);

    if (updErr) {
      console.error(`Failed to update embedding for ${p.id}:`, updErr);
    } else {
      console.log(`Updated embedding for ${p.id}`);
    }
  }
}

async function main() {
  updateFormResponsesTableWithVectorEmbeddings(); // node --loader ts-node/esm src/lib/matchmaker/embeddings.ts
};

main()
